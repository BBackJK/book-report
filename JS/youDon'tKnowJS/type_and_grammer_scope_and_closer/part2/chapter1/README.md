# 스코프란 무엇인가

변수를 프로그램에 추가하면 다음과 같은 질문들이 생각날 수 있다.

* 변수는 **어디에** 살아있는가? (어디에 저장되는가?)
* 필요할 때 프로그램은 어떻게 변수를 찾는가?

이러한 특정 장소에 변수를 저장하고 나중에 그 변수를 찾는 데는 잘 정의된 규칙이 필요하다.

이러한 규칙을 바로 **스코프**라고 한다.

## 1. 컴파일러 이론

자바스크립트는 일반적으로 **동적** 또는 **인터프리터** 언어로 분류하나 사실은 **컴파일러 언어** 이다.

물론 자바스크립트가 전통적인 많은 컴파일러 언어처럼 코드를 미리 컴파일하거나 컴파일한 결과를 분산시스템에서 이용할 수 있는 것은 아니다.

하지만 자바스크립트 엔진은 전통적인 컴파일러 언어에서 컴파일러가 하는 일의 상당 부분을 우리가 아는 것보다 세련된 방식으로 처리한다.

전통적인 컴파일러 언어는 소스 코드가 실행되기 전에 보통 3단계를 거치는데, 이를 **컴파일레이션 (compilation)** 이라고 한다.

#### 토크나이징 (Tokenizing) / 렉싱 (Lexing)

문자열을 나누어 **토큰**이라 불리는 의미 있는 조각으로 만드는 과정

예를 들어 `var a = 2;`라는 것은 다음과 같이 나누어진다.

* var,
* a
* =
* 2
* ;

빈칸은 하나의 토큰으로 담길 수도 있고 아닐 수도 있다. 이는 빈칸이 의미가 있냐, 없냐에 따라 달려있다.

> 토큰나이징과 렉싱은 미묘한 차이가 존재하는데, 토큰을 인식할 때 **무상태 방식으로 하는지 상태 유지 방식으로 하는지**에 따라 결정된다. 즉, 토크나이저가 상태 유지 파싱 규칙을 적용해 a가 별개의 토큰인지 다른 토큰의 일부인지를 파악한다면 그것은 렉싱이다.


#### 파싱 (Parsing)

토큰 배열을 프로그램의 문법 구조를 반영하여 중첩 원소를 갖는 트리 형태로 바꾸는 과정이 **파싱**이다.

이러한 파싱의 결과로 만들어진 트리를 **AST (Abstract Syntax Tree - 추상 구문 트리)** 라고 한다.

`var a = 2;`의 트리는 먼저 변수 선언 (Variable Declaration)이라 부르는 최상위 노드에서 시작하고,

최상위 노드는 `a`의 값을 가지는 확인자 (identifier)와 대입 수식 (Assignment Expression) 이라 부르는 자식 노드를 가진다.

대입 수식 자식 노드는 `2`라는 값을 가지는 숫자 리터럴을 자식 노드로 가지고있다.

#### 코드 생성 (Code-Generation)

AST (추상 구문 트리)를 컴퓨터에서 실행 코드로 바꾸는 과정.

`var a = 2;`를 나타내는 AST를 기계어 집합으로 바꾸어 실제로 `a`라는 변수를 생성(메모리를 확보하는 일 등)하고 값을 저장할 방법이 있다고 치자.

> 엔진이 시스템 리소스를 실제 어떻게 관리하는지에 관한 세부 사항은 살펴볼 범위를 넘어서므로 엔진이 필요한 변수를 생성하고 저장할 것이라고 가정하고 넘어가겠다.

**자바스크립트 엔진은 파싱과 코드 생성 과정에서 불필요한 요소를 삭제하는 과정을 거쳐 실행 시 성능을 최적화한다.**

간단히 말하자면, 어떤 자바스크립트 조각이라도 실행되려면 먼저 (보통 바로 직전에!) 컴파일되어야 한다는 것이다.

즉, 자바스크립트 컴파일러는 프로그램 `var a = 2;`를 받아 컴파일하여 바로 실행될 수 있게 한다.


## 2. 스코프 이해하기

스코프를 조금 더 쉽게 이해하기 위해서 대화 형식으로 살펴보자.

### 2.1 출연진

프로그램 `var a = 2;`를 처리할 주역들을 보자.

* **엔진** - 컴파일레이션의 시작부터 끝까지 전 과정과 자바스크립트 프로그램 실행을 책임진다.
* **컴파일러** - 엔진의 친구로, 파싱과 코드 생성의 모든 잡일을 도맡아 한다.
* **스코프** - 엔진의 또 다른 친구로, 선언된 모든 확인자(변수) 검색 목록을 작성하고 유지한다. 또한, 엄격한 규칙을 강제하여 현재 실행 코드에서 ``확인자(변수)의 적용 방식을 결정``한다.

### 2.2 앞과 뒤

프로그램 `var a = 2;`를 보면 하나의 구문으로 보이지만, 출연진 **엔진**은 그렇게 보지 않는다.

**엔진**은 두 개의 사로 다른 구문으로 보는데, 하나는 **컴파일러**가 `컴파일레이션 과정에서 처리할 구문`이고, 다른 하나는 `실행 과정에서 엔진이 처리할 구문`이다.

이 프로그램에서 **첫 번째로 컴파일러가 할 일은 렉싱을 통해 구문을 토큰으로 쪼개는 것**이다. 그 후 토큰을 파싱하여 트리 구조로 만든다.

그리고 나서 코드 생성 과정에서는

1. **컴파일러**가 `var a`를 만나면 **스코프**에게 변수 a가 특정한 스코프 컬렉션 안에 있는지 묻는다. 변수 a가 이미 있다면 **컴파일러**는 선언을 무시하고 지나가고, 그렇지 않으면 **컴파일러**는 새로운 변수 a를 스코프 컬렉션내에 선언하라고 요청한다.

2. 그 후 **컴파일러**는 `a = 2` 대입문을 처리하기 위해 나중에 **엔진**이 실행할 수 있는 코드를 생성한다. **엔진**이 실행하는 코드는 먼저 **스코프**에게 a라 부르는 변수가 현재 스코프 컬렉션 내에서 접근할 수 있는지 확인한다. 가능하다면 **엔진**은 변수 a를 사용하고, 아니라면 **엔진**은 다른 곳을 살핀다.

### 2.3 컴파일러체

2단계에서 **컴파일러**가 생성한 코드를 실행할 때 **엔진**은 변수 a가 선언된 적이 있는지 스코프에서 검색한다.

이 때, **엔진**이 어떤 종류의 검색을 하느냐에 따라 검색 결과가 달라진다.

전자의 경우에서 **엔진**은 변수 a를 찾기 위해 **LHS 검색**을 수행한다. 다른 종류의 검색은 **RHS 검색**이라 부른다.

여기서 L과 R은 왼쪽, 오른쪽을 뜻하는데 이 것은 대입의 연산 방향을 말한다.

즉, **LHS 검색은 변수가 대입 연산자의 왼쪽에 있을 때 수행**하고, **RHS 검색은 변수가 대입 연산자의 오른쪽에 있을 때 수행**한다.

좀 더 자세하게 살펴보면 **RHS 검색은 단순히 특정 변수의 값을 찾는 것**과 다를 바 없지만, **LHS 검색은 값을 넣어야 하므로 변수 컨테이너를 찾는다.**

```js
console.log(a);
```

a에 대한 참조는 RHS 참조다. a에 아무것도 대입하지 않기 때문이다. 대신 a의 값을 가져와 `console.log()`에 넘겨준다.

```js
a = 2;
```

a에 대한 참조는 LHS 참조이다. 현재 a 값을 신경 쓸 필요 없이 `= 2` 대입 연산을 수행할 대상 변수를 찾기 때문이다.

> 개념적으로 대입할 대상(LHS)과 대입한 값(RHS)이라고 생각하는 것이 낫다.

```js
function foo(a) {
  console.log(a); // 2
}
foo(2);
```

마지막 줄에서 `foo()`를 호출하는 데 RHS 참조를 사용한다. 즉, **"가서 foo의 값을 찾아 내게 가져와라"** 라는 뜻이다.

인수로 값 2를 함수 `foo()`에 넘겨줄 때 값 2를 인자 a에 대입하는 연산이 일어난다. 이 인자 a에 대한 대입 연산을 위해 LHS 검색이 수행된다.

변수 a에 대한 RHS 참조 역시 수행되는데, 그 결과값은 `console.log()`에 넘겨진다.

또한 `console.log()`가 실행되려면 참조가 필요하다. `console`객체를 RHS 검색하여 `log` 메소드가 있는지 확인한다.

### 2.4 엔진과 스코프의 대화

```js
function foo(a) {
  console.log(a); // 2
} 
foo(2);
```

이 실행 과정을 대화라고 생각해보면

* 엔진 : 안녕. 스코프, foo에 대한 RHS 참조가 필요해. foo 라고 들어본 적이 있니?
* 스코프 : 응, 들어봤어. 컴파일러가 좀 전에 선언하더라고, foo는 함수야. 이걸 보면 돼.
* 엔진 : 고마워!, 나는 이제 foo를 실행해야겠어.
* 엔진 : 이봐, 스코프. a에 대한 LHS 참조도 구해야 하는데, 들어본 적 있어?
* 스코프 : 당연하지, 컴파일러가 a를 foo의 인자로 좀 전에 선언했어. 이걸 봐
* 엔진 : 항상 도와줘서 고마워. 이제 2를 a에 대입할 시간이야.
* 엔진 : 스코프, 자꾸 귀찮게 해서 미안한다, console에 대한 RHS 검색이 필요해. 해줄 수 있니?
* 스코프 : 문제없어. 자, console를 찾았어. 내장돼 있더라.
* 엔진 : 완벽해. 이제 log()를 찾아볼까.
* 엔진 : 스코프! a의 RHS 참조 찾는 것을 도와줄 수 있을까? 나한테도 있긴 할테지만, 확실히 해두고 싶어!
* 스코프 : 물론이지, 여기있어!
* 엔진 : 좋아! 이제 a의 값을... 값은 2구나. log에 넘기자.

#### 퀴즈

엔진의 역할을 맡아 스코프와 대화해보자.

```js
function foo(a) {
  var b = a;
  return a + b;
}
var c = foo(2);
```

1. 모든 LHS 검색을 찾아보라 (총 3개) 

  c = foo(2), a = 2, b = a

2. 모든 RHS 검색을 찾아보라 (총 4개)

  foo, = a, a + ..., ... + b

## 3. 중첩 스코프

스코프는 확인자 이름으로 변수를 찾기 위한 규칙의 집합이라고 앞서 말한 바 있다.

그러나 대개 고려해야 할 스코프는 여러 개이다.

하나의 블록이나 함수는 다른 블록이나 함수 안에 중첩될 수 있으므로 스코프도 다른 스코프안에 중첩될 수 있다.

따라서 대상 변수를 현재 스코프에서 발견하지 못한다면 엔진은 다음 바깥의 스코프로 넘어가는 식으로 변수를 찾거나 글로벌 스코프라고 불리우는 가장 바깥 스코프에 도달할 때까지 계속한다.

```js
function foo(a) {
  console.log(a + b);
}

var b = 2;
foo(2)  // 4
```

b에 대한 RHS 참조는 함수 foo 안에서 처리할 수 없고, 함수를 포함하는 스코프 (위와 같은 경우에는 글로벌 스코프)에서 처리한다.

## 4. 오류

LHS와 RHS를 구분하는 것이 왜 중요할까?

이 두 종류의 검색 방식은 변수가 아직 선언되지 않았을 때 서로 다르게 동작하기 때문이다.

```js
function foo(a) {
  console.log(a + b);
  b = a;
}

foo (2);
```

b에 대한 첫 RHS 검색이 실패하면 다시는 b를 찾을 수 없다.

RHS 검색이 중첩 스코프 안 어디에서도 변수를 찾지 못하면 엔진이 `Reference Error`를 발생시킨다.

반면, 엔진이 LHS 검색을 수행하여 변수를 찾지 못하고 최상위 층에 도착할 때 (Strict Mode가 아니라면) 글로벌 스코프는 엔진이 검색하는 이름을 가진 새로운 변수를 생성해서 엔진에게 넘겨준다. 즉, "없어, 없었지만 내가 널 위해 하나 만들어주지"의 느낌이다.



