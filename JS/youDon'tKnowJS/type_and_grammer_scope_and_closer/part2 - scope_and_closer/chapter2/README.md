# 렉시컬 스코프

스코프는 두 가지 방식으로 동작한다.

첫 번째 방식은 다른 방식보다 훨씬 더 일반적이고 다수의 프로그래밍 언어가 사용하는 방식이다. 

이 방식을 **렉시컬 스코프**라고 부르며,

다른 방식은 Bash Scripting이나 Perl의 일부 모드와 같은 몇몇 언어에서 사용하는 방식인 **동적 스코프**라고 부른다.


## 1. 렉스타임

일반적인 언어의 컴파일러는 첫 단계를 전통적으로 토크나이징 혹은 렉싱이라 불리는 작업으로 시작한다.

렉싱 처리 과정에서는 **소스 코드 문자열을 분석하여 상태 유지 파싱의 결과로 생성된 토큰에 의미를 부여**한다.

순환적인 정의로써는 렉시컬 스코프는 **렉싱 타임**에 정의되는 스코프이다.

즉, 렉시컬 스코프는 개발자가 코드를 짤 때 **변수와 스코프 블록을 어디서 작성하는가에 기초해서 렉서가 코드를 처리할 때 확정**된다.

```js
function foo(a) {
  var b = a * 2;
  function bar(c) {
    console.log(a, b, c);
  }
  bar (b * 3);
}
foo(2); // 2, 4, 12
```

이 예제 코드에는 3개의 중첩 스코프가 있다.

1. 글로벌 스코프는 하나의 확인자 foo만 있다.
2. foo 스코프는 3개의 확인자 a, bar, b를 포함하고 있다.
3. bar 스코프는 하나의 확인자 c만 있다.

## 1.1 검색

엔진은 스코프 버블의 구조와 상대적 위치를 통해 어디를 검색해야 확인자를 찾을 수 있는지 안다.

위 코드에서 엔진은 `console.log()`구문을 실행하고 3개의 참조된 변수 a, b, c를 검색한다.

검색은 가장 안쪽의 스코프인 `bar()` 함수의 스코프에서 시작한다.

여기서 a를 찾지 못하면 다음으로 가장 가까운 스코프인 `foo()`로 올라가고, 이곳에서도 찾지 못하면 글로벌 스코프에서 찾는다.

그리고 찾는 즉시 검색을 중단한다. (여러 스코프에 존재해도 가장 안쪽에서 찾으면 그 즉시 중단)

## 2. 렉시컬 속이기

렉시컬 스코프는 개발자가 작성할 때 함수를 어디에 선언했는지에 따라 결정된다. 그렇다면 런타임 때 어떻게 렉시컬 스코프를 수정할 수 있을까?

자바스크립트에서는 렉시컬 스코프를 속일 수 있는 두 가지 방법이 있다. 두 방법 모두 권장하지는 않는 방법이다.

왜냐하면 성능을 떨어뜨리기 때문이다.

### 2.1 eval

자바스크립트의 `eval()` 함수는 문자열을 인자로 받아들여 실행 시점에 문자열의 내용을 코드의 일부분처럼 처리한다. 즉, 처음 작성한 코드에 프로그램에서 생성한 코드를 집어 넣어 마치 처음 작성될 때부터 있던 것처럼 실행한다.

```js
function foo(str, a) {
  eval(str);
  console.log(a, b);
}

var b = 2;
foo ("var b = 3;", 1);  // 1, 3
```

문자열 `var b = 3;`은 `eval()`이 호출되는 시점에 원래 있던 코드인 것처럼 처리된다.

이 코드는 새로운 변수 b를 선언하면서 이미 존재하는 `foo()`의 렉시컬 스코프를 수정한다.

즉, 실제로 `foo()` 안에 변수 b를 생성하여 바깥 스코프(글로벌 스코프)에 선언된 변수 b를 지운다(?)

### 2.2 with

이 기능 또한 렉시컬 스코프를 속일 수 있는 기능. 이 기능은 없어질 예정이므로 다루지 않겠다.

### 2.3 성능

자바스크립트 엔진은 컴파일레이션 단계에서 상당수의 최적화 작업을 진행한다.

이 최적화의 일부분이 하는 핵심 작업은 **렉싱된 코드를 분석하여 모든 변수와 함수 선언문이 어디에 있는지 파악하고 실행 과정에서 확인자 검색을 더 빠르게 하는 것**이다.

그러나 `eval()`이나 `with`가 코드에 있다면 엔진은 미리 확인해둔 확인자의 위치가 틀릴 수도 있다고 가정해야 한다.

즉, 코드의 성능이 떨어진다.

